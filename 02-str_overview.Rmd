# Short-term rentals in Prince Edward County: Market overview

<style type="text/css">
  body{
  font-family: Futura, Helvetica, Arial;
}
</style>

<br>

```{r setup, include = FALSE, echo = FALSE}

library(here)
source(here("R", "01_startup.R"))

knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(include = FALSE)
knitr::opts_chunk$set(message = FALSE)
knitr::opts_chunk$set(warning = FALSE)

# Function for checking file modifications
mtime <- function(files) lapply(Sys.glob(files), function(x) file.info(x)$mtime)

# Set this to TRUE to output PDF figures
build_figures <- FALSE


```

```{r new_objects, cache=TRUE, cache.lazy=FALSE, cache.extra = mtime(here("output", "str_processed.qsm"))}

qload(here("output", "str_processed.qsm"), nthreads = availableCores())
qload(here("output", "geometry.qsm"), nthreads = availableCores())

daily <- 
  daily %>% 
  # to not report on incomplete numbers, start at a date when VRBO is in our dataset
  filter(date >= "2017-06-01")

# 2021 active
active_2021 <- 
  daily %>%
  filter(housing, status %in% c("R", "A"), 
         date >= start_2021) %>%
  pull(property_ID) %>% 
  unique()
  
# 2021 revenue
revenue_2021 <-
  daily %>%
  filter(housing, status == "R", 
         date >= start_2021) %>%
  group_by(property_ID) %>%
  summarize(revenue_2021 = sum(price), .groups = "drop") %>% 
  inner_join(property, ., by = "property_ID")

# 2019 active
active_2019 <- 
  daily %>%
  filter(housing, status %in% c("R", "A"), date <= end_2019, 
         date >= start_2019) %>%
  pull(property_ID) %>% 
  unique()

# 2019 revenue
revenue_2019 <-
  daily %>%
  filter(housing, status == "R", date <= end_2019, 
         date >= start_2019) %>%
  group_by(property_ID) %>%
  summarize(revenue_2019 = sum(price), .groups = "drop") %>% 
  inner_join(property, ., by = "property_ID")

# Active listings
active_listings <- 
  daily %>% 
  filter(housing, status != "B") %>% 
  count(date, listing_type) %>% 
  group_by(listing_type) %>% 
  mutate(n = slide_dbl(n, mean, .before = 6, .complete = TRUE)) %>% 
  ungroup()

active_listings <- 
  daily %>% 
  filter(housing, status != "B") %>% 
  count(date) %>% 
  mutate(n = slide_dbl(n, mean, .before = 6, .complete = TRUE),
         listing_type = "All listings") %>% 
  bind_rows(active_listings) %>% 
  arrange(date, listing_type)

# Daily variation
daily_variation <- 
  daily %>% 
  filter(housing, status != "B", date != "2020-02-29") %>%
  group_by(date) %>% 
  summarize("Active listings" = n(), Revenue = sum(price[status == "R"])) %>% 
  mutate(across(where(is.numeric), 
                function(x) slide_dbl(x, ~{(.x[366] - .x[1]) / .x[1]}, 
                                      .before = 365, .complete = FALSE))) %>% 
  pivot_longer(-date, names_to = "var", values_to = "value") %>% 
  group_by(var) %>% 
  mutate(value = slide_dbl(value, mean, .before = 13, .complete = TRUE)) %>% 
  ungroup() %>% 
  filter(!is.na(value), !is.infinite(value)) %>% 
  group_by(date) %>% 
  filter(n() == 2, date >= as.Date("2017-06-01") + years(1)) %>% 
  ungroup()

# EW breakdown
EW_breakdown <- 
  daily %>% 
  filter(housing, status != "B", date >= start_2019, 
         !c(date >= start_2020 & date <= end_2020)) %>% 
  group_by(date, ward) %>% 
  summarize(n = n(),
            revenue = sum(price[status == "R"])) %>% 
  left_join(st_drop_geometry(EW)) %>% 
  group_by(ward, dwellings) %>% 
  summarize(active_listings = mean(n[date >= start_2021]),
            active_2019 = mean(n[date < start_2021]),
            active_growth_2019_2021 = (active_listings - active_2019) / active_2019,
            daily_rev = sum(revenue[date >= start_2021]) / yday(max(date)),
            rev_2019 = sum(revenue[date < start_2021]) / yday(max(date)),
            rev_growth_2019_2021 = (daily_rev - rev_2019) / rev_2019,
            .groups = "drop") %>% 
  mutate(listings_pct = active_listings / sum(active_listings, na.rm = TRUE),
         listings_pct_dwellings = active_listings / dwellings,
         rev_pct = daily_rev / sum(daily_rev)) %>% 
  select(ward, active_listings, active_growth_2019_2021, listings_pct,
         listings_pct_dwellings, daily_rev, rev_pct, rev_growth_2019_2021)

# Active listings by EW
active_EW <-
  daily %>%
  filter(housing, status != "B", date >= start_2021) %>%
  count(ward, date) %>% 
  group_by(ward) %>% 
  summarize(n = mean(n, na.rm = TRUE)) %>%
  left_join(EW, .) %>% 
  mutate(percentage = n / dwellings, n = round(n)) %>% 
  select(ward, n, dwellings, percentage)

# Active listings by DA
active_DA <-
  daily %>%
  filter(housing, status != "B", date >= start_2021) %>%
  left_join(select(st_drop_geometry(property), property_ID, GeoUID)) %>% 
  count(GeoUID, date) %>% 
  group_by(GeoUID) %>% 
  summarize(n = mean(n, na.rm = TRUE)) %>%
  left_join(DA, .) %>% 
  mutate(percentage = n / dwellings, n = round(n),
         percentage = if_else(dwellings <= 4, NA_real_, percentage)) %>% 
  relocate(geometry, .after = last_col())

# Listing type breakdown
listing_type_breakdown <- 
  daily %>% 
  filter(housing, status != "B", date >= start_2021) %>% 
  group_by(listing_type) %>% 
  summarize(
    active_listings = round(n() / yday(max(date))),
    revenue = sum(price[status == "R"]),
    .groups = "drop") %>% 
  mutate(pct_of_listings = active_listings / sum(active_listings),
         pct_of_revenue = revenue / sum(revenue))

listing_type_breakdown <- 
  daily %>% 
  filter(housing, status != "B", date >= start_2019 - years(1), 
         date <= end_2019 - years(1)) %>% 
  group_by(listing_type) %>% 
  summarize(active_2019 = round(n() / 365)) %>% 
  left_join(listing_type_breakdown, .) %>% 
  mutate(pct_listing_growth_2019_2021 = (active_listings - active_2019) / active_2019) %>% 
  select(-active_2019)

# Host revenue table for calculations and table
host_rev <-
  daily %>%
  filter(housing, date >= start_2021, 
         status == "R", !is.na(host_ID)) %>%
  group_by(host_ID) %>%
  summarize(rev = sum(price))

host_rev_2019 <-
  daily %>%
  filter(housing, date >= start_2019, date <= end_2019,
         status == "R", !is.na(host_ID)) %>%
  group_by(host_ID) %>%
  summarize(rev = sum(price))

rm(property, daily, GH, DA, city)


```

```{r exec_summ, cache = TRUE, cache.lazy = FALSE, cache.extra = mtime(here("output", "str_processed.qsm"))}

qload(here("output", "str_processed.qsm"), nthreads = availableCores())

# Average active and blocked daily listings in 2021
avg_listings <- 
  daily %>% 
  filter(housing, date >= start_2021) %>% 
  count(date, B = status == "B") %>% 
  group_by(B) %>% 
  summarize(avg = round(mean(n), digit = -1), .groups = "drop")

avg_listings_active <- 
  avg_listings$avg[1] %>% 
  prettyNum(",")

# Average active and blocked daily listings in 2019
avg_listings_2019 <- 
  daily %>% 
  filter(housing, date >= start_2019, date <= end_2019) %>% 
  count(date, B = status == "B") %>% 
  group_by(B) %>% 
  summarize(avg = round(mean(n), digit = -1), .groups = "drop")

avg_listings_active_2019 <- 
  avg_listings_2019$avg[1] %>% 
  prettyNum(",")

# Daily revenue in 2021
daily_rev <- 
  {{revenue_2021$revenue_2021 %>% 
  sum()}/yday(max(daily$date))} %>% 
  round(-3) %>% 
  prettyNum(",") %>% 
  paste0("$", .)

# Daily revenue in 2019
daily_rev_2019 <- 
  {{revenue_2019$revenue_2019 %>% 
  sum()}/365} %>% 
  round(-3) %>% 
  prettyNum(",") %>% 
  paste0("$", .)

# EH listings
eh_listings <- 
  listing_type_breakdown %>% 
  filter(listing_type == "Entire home/apt") %>% 
  pull(pct_of_listings) %>% 
  scales::percent(0.1)

# EH revenue
eh_revenue <- 
  listing_type_breakdown %>% 
  filter(listing_type == "Entire home/apt") %>% 
  pull(pct_of_revenue) %>% 
  scales::percent(0.1)

# Host revenue in 2021
host_rev_top_10 <- 
  host_rev %>% 
  summarize(top_10 = sum(rev[rev > quantile(rev, .9)]) / sum(rev)) %>% 
  pull(top_10) %>% 
  scales::percent(0.1)

host_rev_top_1 <- 
  host_rev %>% 
  summarize(top_1 = sum(rev[rev > quantile(rev, .99)]) / sum(rev)) %>% 
  pull(top_1) %>% 
  scales::percent(0.1)

# Host revenue in 2019
host_rev_top_10_2019 <- 
  host_rev_2019 %>% 
  summarize(top_10 = sum(rev[rev > quantile(rev, .9)]) / sum(rev)) %>% 
  pull(top_10) %>% 
  scales::percent(0.1)

host_rev_top_1_2019 <- 
  host_rev_2019 %>% 
  summarize(top_1 = sum(rev[rev > quantile(rev, .99)]) / sum(rev)) %>% 
  pull(top_1) %>% 
  scales::percent(0.1)

# 2021 ML listings
ml_listings <- 
  daily %>% 
  filter(housing, status != "B", date >= start_2021) %>% 
  count(multi) %>% 
  summarize(ML = n[2] / sum(n)) %>% 
  pull(ML) %>% 
  scales::percent(0.1)

# 2021 ML revenue
ml_revenue <- 
  daily %>% 
  filter(housing, status == "R", date >= start_2021) %>% 
  group_by(multi) %>% 
  tally(price) %>% 
  summarize(multi_rev = n[2] / sum(n)) %>% 
  pull(multi_rev) %>% 
  scales::percent(0.1)

# 2019 ML listings
ml_listings_2019 <- 
  daily %>% 
  filter(housing, status != "B", date >= start_2021, 
         date <= end_2019) %>% 
  count(multi) %>% 
  summarize(ML = n[2] / sum(n)) %>% 
  pull(ML) %>% 
  scales::percent(0.1)

# 2019 ML revenue
ml_revenue_2019 <- 
  daily %>% 
  filter(housing, status == "R", date >= start_2021, 
         date <= end_2019) %>% 
  group_by(multi) %>% 
  tally(price) %>% 
  summarize(multi_rev = n[2] / sum(n)) %>% 
  pull(multi_rev) %>% 
  scales::percent(0.1)

rm(property, daily, GH)

```

**There are on a daily average `r avg_listings_active` active STR listings in Prince Edward County housing units in 2021, which collectively earns `r daily_rev` a day. This is a dramatic decline in comparison to 2019 (`r avg_listings_active_2019` daily active listings). STR activity is very decentralized on the island, but is less common on the Northern part. The quasi totality (`r eh_listings`) of Prince Edward County’s STR listings are entire homes, and entire homes are responsible for `r eh_revenue` of all revenue. Revenue is concentrated unevenly among hosts, with the top 10% earning almost half (`r host_rev_top_10`) of revenue, and the top 1% earning `r host_rev_top_1`. Commercial operators who control multiple STR listings account for half of listings (`r ml_listings`) and revenue (`r ml_revenue`).**

<br>

## Active daily listings and annual revenue

```{r para_1, cache = TRUE, cache.lazy = FALSE, cache.extra = mtime(here("output", "str_processed.qsm"))}

qload(here("output", "str_processed.qsm"), nthreads = availableCores())

avg_listings_active_2019 <- 
  avg_listings_2019$avg[1] %>% 
  prettyNum(",")

# Average number of hosts in 2021 (taking out blocked 365 days)
avg_hosts <- 
  daily %>% 
  filter(housing, status != "B", date >= start_2021) %>%
  count(date, host_ID) %>% 
  count(date) %>% 
  summarize(hosts = round(mean(n), digit = -1), .groups = "drop") %>% 
  pull(hosts) %>% 
  prettyNum(",")

# Average number of hosts in 2019 (taking out blocked 365 days)
avg_hosts_2019 <- 
  daily %>% 
  filter(housing, status != "B", date >= start_2019, 
         date <= end_2019) %>%
  count(date, host_ID) %>% 
  count(date) %>% 
  summarize(hosts = round(mean(n), digit = -1), .groups = "drop") %>% 
  pull(hosts) %>% 
  prettyNum(",")

# Average revenue per active listing in 2021
avg_rev_per_listing <- 
  # Since there aren't 365 days in 2021, we need to avg per day
  {(sum(revenue_2021$revenue_2021) / yday(max(daily$date))) /
    daily %>% 
    filter(housing, status != "B", date >= start_2021) %>% 
    count(date) %>% 
    summarize(avg_rev_per_active = round(mean(n)), .groups = "drop")} %>% 
  as.vector() %>% 
  round(digit = -1) %>% 
  prettyNum(",") %>% 
  paste0("$", .)

# Average revenue per active listing in 2019
avg_rev_per_listing_2019 <- 
  {(sum(revenue_2019$revenue_2019) / 365) /
    daily %>% 
    filter(housing, status != "B", date >= start_2019, date <= end_2019) %>% 
    count(date) %>% 
    summarize(avg_rev_per_active_2019 = round(mean(n)), .groups = "drop")} %>% 
  as.vector() %>% 
  round(digit = -1) %>% 
  prettyNum(",") %>% 
  paste0("$", .)

#' Average revenue per active host in 2021
avg_rev_per_host <- 
  {(sum(revenue_2021$revenue_2021) / yday(max(daily$date))) /
    daily %>% 
    filter(housing, status != "B", date >= start_2021) %>%
    group_by(date) %>% 
    summarize(n_hosts = length(unique(host_ID)), .groups = "drop_last") %>% 
    summarize(avg_n_hosts = round(mean(n_hosts)), .groups = "drop")} %>% 
  round(digit = -1) %>% 
  prettyNum(",") %>% 
  paste0("$", .)

#' Average revenue per active host in 2019
avg_rev_per_host_2019 <- 
  {(sum(revenue_2019$revenue_2019) / 365) /
    daily %>% 
    filter(housing, status != "B", date >= start_2019, date <= end_2019) %>% 
    group_by(date) %>% 
    summarize(n_hosts = length(unique(host_ID)), .groups = "drop_last") %>% 
    summarize(avg_n_hosts20 = round(mean(n_hosts)), .groups = "drop")} %>% 
  round(digit = -1) %>% 
  prettyNum(",") %>% 
  paste0("$", .)

rm(property, daily, GH)

```

``` {r make_fig_1_1}

figure_1_1_fun <- function(regular = "", condensed = "") {
  
  active_listings %>% 
  ggplot(aes(date, n, colour = listing_type, size = listing_type)) +
  geom_line(na.rm = TRUE) +
  scale_y_continuous(name = NULL, label = scales::comma) +
  scale_colour_manual(name = NULL, values = col_palette[c(5, 1:3)],
                      guide = guide_legend(
                        override.aes = list(size = c(1.5, 0.75, 0.75, 0.75)))) +
  scale_size_manual(values = c("All listings" = 1.5, "Entire home/apt" = 0.75,
                               "Private room" = 0.75, "Shared room" = 0.75),
                    guide = "none") +
  theme_minimal() +
  theme(legend.position = "bottom", panel.grid.minor.x = element_blank(),
        text = element_text(family = regular))

}

if (build_figures) {
  ggsave(here("output", "figures", "figure_1_1.pdf"), 
         plot = figure_1_1_fun("Futura", "Futura Condensed"), 
         width = 8, height = 5, units = "in", useDingbats = FALSE)
  
  extrafont::embed_fonts(here("output", "figures", "figure_1_1.pdf"))
}

```

Active daily listings are listings which were displayed on Airbnb or Vrbo on a given day, and were either reserved or available for a reservation. It is the most reliable means of determining the overall size of the STR market in a location, particularly with respect to change over time. In 2021, there was an average of `r avg_listings_active` active daily listings (Figure \@ref(fig:fig-1-1)) operated by an average of `r avg_hosts` hosts. These hosts earned on a daily average `r daily_rev` in 2021—an average of `r avg_rev_per_listing` per daily active listing or `r avg_rev_per_host` per daily active host. These numbers are only a portion of Prince Edward County's STR market from before the pandemic. In 2019, the STR market revenue amounted to a daily average of`r daily_rev_2019`, with an average of `r avg_listings_active_2019` active listings on a given day operated by `r avg_hosts_2019` hosts. In 2019, the average listing earned `r avg_rev_per_listing_2019` a night and the average host, `r avg_rev_per_host_2019` a night. While there are less listings and hosts in 2021, which collectively earn less revenue, they make more profit then before the pandemic on an individual level.

``` {r fig-1-1, include = TRUE, fig.cap = '(ref:fig-1-1)', fig.align = "center"}

figure_1_1_fun()

```

(ref:fig-1-1) _Active daily STRs in Prince Edward County (7-day average)_

``` {r para_2, cache = TRUE, cache.lazy = FALSE, cache.extra = mtime(here("output", "str_processed.qsm"))}

qload(here("output", "str_processed.qsm"), nthreads = availableCores())

# Average blocked daily listings in 2021
avg_listings_blocked <- 
  avg_listings$avg[2] %>% 
  prettyNum(",")

# Average blocked daily listings in 2019
avg_listings_blocked_2019 <- 
  avg_listings_2019$avg[2] %>% 
  prettyNum(",")

# Average revenue per all listings in 2021
avg_revenue_all_listings <- 
  {(revenue_2021$revenue_2021 %>% 
  mean()) / yday(max(daily$date))} %>% 
  round(digit = -1) %>% 
  prettyNum(",") %>% 
  paste0("$", .)

# Average revenue per all listings in 2019
avg_revenue_all_listings_2019 <- 
  {(revenue_2019$revenue_2019 %>% 
  mean()) / 365} %>% 
  round(digit = -1) %>% 
  prettyNum(",") %>% 
  paste0("$", .)

# Average revenue per all hosts in 2021
avg_revenue_all_hosts <- 
  {(revenue_2021 %>% 
  st_drop_geometry() %>%
  filter(!is.na(host_ID)) %>%
  group_by(host_ID) %>% 
  summarize("host_rev" = sum(revenue_2021)) %>% 
  summarize("avg_host_rev" = mean(host_rev)) %>% 
  pull(avg_host_rev)) / yday(max(daily$date))} %>% 
  round(., -1) %>% 
  paste0("$", .)

# Average revenue per all hosts in 2019
avg_revenue_all_hosts_2019 <- 
  {(revenue_2019 %>% 
  st_drop_geometry() %>%
  filter(!is.na(host_ID)) %>%
  group_by(host_ID) %>% 
  summarize("host_rev" = sum(revenue_2019)) %>% 
  summarize("avg_host_rev" = mean(host_rev)) %>% 
  pull(avg_host_rev)) / 365}  %>% 
  round(., -1) %>% 
  paste0("$", .)

# Non-housing active listings in 2021
non_housing_listings <- 
  daily %>% 
  filter(!housing, status != "B", date >= start_2021) %>%
  count(date) %>% 
  summarize(non_housing = round(mean(n), digit = -1)) %>% 
  pull(non_housing) %>% 
  prettyNum(",")

# Non-housing active listings in 2019
non_housing_listings_2019 <- 
  daily %>% 
  filter(!housing, status != "B", date >= start_2019, date <= end_2019) %>%
  count(date) %>% 
  summarize(non_housing = round(mean(n), digit = -1)) %>% 
  pull(non_housing) %>% 
  prettyNum(",")

rm(property, daily, GH)

```

There was also a daily average of `r avg_listings_blocked` listings which were visible on the Airbnb and Vrbo websites but were blocked by the host from receiving reservations (which is more than pre-Covid years, with 2019 having on average `r avg_listings_blocked_2019` blocked listings on a given day). The presence of these listings can erroneously suggest that a territory’s STR market is larger than it is. When these blocked but inactive listings are included, the average listing earned `r avg_revenue_all_listings` daily in 2021, and the average host earned `r avg_revenue_all_hosts` daily. Finally, there was a daily average of `r non_housing_listings` listings that were not located in private housing units (B&Bs, hotels, etc.), which have been excluded from the analysis in this report. All the material which follows pertain to short-term rentals located in Prince Edward County’s residential housing stock.

``` {r para_3, cache = TRUE, cache.lazy = FALSE, cache.extra = mtime(here("output", "str_processed.qsm"))}

qload(here("output", "str_processed.qsm"), nthreads = availableCores())

# Date and amount of highest activity
highest_activity <- 
  daily %>% 
  filter(housing, status != "B") %>% 
  count(date) %>% 
  filter(n == max(n)) %>% 
  group_by(date) %>% 
  summarize(daily_max = round((n), digit = -1)) %>% 
  slice(1)

highest_activity_date <-
  highest_activity$date %>% 
  {paste0(month.name[as.numeric(substr(., 6, 7))], " ", substr(., 1, 4))}

highest_activity_amount <- 
  highest_activity$daily_max %>% 
  prettyNum(",")

# Active listing YOY change in 2019
active_yoy_change_2019 <- 
  daily %>% 
  filter(housing, status != "B", date >= start_2019 - years(1), 
         date <= end_2019) %>% 
  group_by(year_2019 = date >= start_2019) %>% 
  summarize(active_listings = n() / 365,
            revenue = sum(price[status == "R"]), .groups = "drop") %>% 
  summarize(across(c(active_listings, revenue), ~{(.x[2] - .x[1]) / .x[1]}),
            .groups = "drop")

active_yoy_listings_2019 <- 
  active_yoy_change_2019$active_listings %>% 
  scales::percent(accuracy = 0.1)

active_yoy_revenue_2019 <- 
  active_yoy_change_2019$revenue %>% 
  scales::percent(accuracy = 0.1)

# Active listing change 2019 to 2021
active_yoy_change <- 
  daily %>% 
  filter(housing, status != "B", date >= start_2019, 
         !c(date >= start_2020 & date <= end_2020)) %>% 
  group_by(year_2021 = date >= start_2021) %>% 
  summarize(active_listings = n() / yday(max(date)),
            revenue = sum(price[status == "R"])  / yday(max(date)), .groups = "drop") %>% 
  summarize(across(c(active_listings, revenue), ~{(.x[2] - .x[1]) / .x[1]}),
            .groups = "drop")

active_yoy_listings <- 
  active_yoy_change$active_listings %>% 
  {. * -1} %>% 
  scales::percent(accuracy = 0.1)

active_yoy_revenue <- 
  active_yoy_change$revenue %>% 
  {. * -1} %>% 
  scales::percent(accuracy = 0.1)

rm(property, daily, GH)

```

Active daily listings peaked in `r highest_activity_date` at `r highest_activity_amount`, and have since declined. Due to the Covid-19 pandemic, there were `r active_yoy_listings` fewer active listings on average per day in 2021 than in 2019, and `r active_yoy_revenue` less revenue on average per day. Prior to the pandemic, it seems like Prince Edward County's STR market had leveled off, with, for example, a slow growth between 2018 and 2019—active listings and revenue respectively increased by `r active_yoy_listings_2019` and `r active_yoy_revenue_2019` from 2018 to 2019. It is likely that this plateauing trend would have continued in 2020 and 2021 in the absence of a pandemic. In general, the number of STR listings available in Prince Edward County follows a strongly seasonal pattern, with the bulk of activity happening in what we call "summer months", the high-season between May and September included (Figure \@ref(fig:fig-1-1)). Detailed information about seasonality in Prince Edward County will be presented in the next chapter.
  
<br>

## Location of STR listings and revenue

``` {r para_4}

picton_listing_pct <- 
  EW_breakdown %>% 
  filter(ward == "Picton") %>% 
  pull(listings_pct) %>% 
  scales::percent(0.1)

picton_rev_pct <- 
  EW_breakdown %>% 
  filter(ward == "Picton") %>% 
  pull(rev_pct) %>% 
  scales::percent(0.1)

hallowell_listing_pct <- 
  EW_breakdown %>% 
  filter(ward == "Hallowell") %>% 
  pull(listings_pct) %>% 
  scales::percent(0.1)

hallowell_rev_pct <- 
  EW_breakdown %>% 
  filter(ward == "Hallowell") %>% 
  pull(rev_pct) %>% 
  scales::percent(0.1)

wellington_listing_pct <- 
  EW_breakdown %>% 
  filter(ward == "Wellington") %>% 
  pull(listings_pct) %>% 
  scales::percent(0.1)

wellington_rev_pct <- 
  EW_breakdown %>% 
  filter(ward == "Wellington") %>% 
  pull(rev_pct) %>% 
  scales::percent(0.1)

picton_per_cap <- 
  EW_breakdown %>% 
  filter(ward == "Picton") %>% 
  pull(listings_pct_dwellings) %>% 
  scales::percent(0.1)

wellington_per_cap <- 
  EW_breakdown %>% 
  filter(ward == "Wellington") %>% 
  pull(listings_pct_dwellings) %>% 
  scales::percent(0.1)

bloomfield_per_cap <- 
  EW_breakdown %>% 
  filter(ward == "Bloomfield") %>% 
  pull(listings_pct_dwellings) %>% 
  scales::percent(0.1)

min_per_dwellings <- 
  EW_breakdown %>%
  filter(!is.na(ward), !ward %in% c("Bloomfield", "Wellington")) %>% 
  pull(listings_pct_dwellings) %>% 
  min() %>% 
  scales::percent(0.1)

max_per_dwellings <- 
  EW_breakdown %>% 
  filter(!is.na(ward), !ward %in% c("Bloomfield", "Wellington")) %>% 
  pull(listings_pct_dwellings) %>% 
  max() %>% 
  scales::percent(0.1)

```

```{r on_water, cache = TRUE, cache.lazy = FALSE}

qload(here("output", "geometry.qsm"), nthreads = availableCores())

ocean <-
  read_sf(here("data", "shapefiles", "lhy_000h16a_e.shp")) %>%
  st_transform(32618)

ocean <-
  ocean %>%
  st_filter(select(city, -everything()))

river <-
  read_sf(here("data", "shapefiles", "lhy_000c16a_e.shp")) %>%
  st_transform(32618)

river <-
  river %>%
  st_filter(select(city, -everything()))

water <- rbind(select(river, -everything()), select(ocean, -everything()))

rm(ocean, river, city)
```

``` {r make_fig_1_2}

figure_1_2_fun <- function(regular = "", condensed = "") {
  
  left_map <- 
    active_EW %>% 
    ggplot() +
    geom_sf(data = province, colour = "transparent", fill = "grey93") +
    geom_sf(aes(fill = percentage), colour = "white") +
    geom_sf(data = water, fill = "white", colour = "transparent") +
    scale_fill_gradientn(colors = col_palette[c(5, 3, 4, 6)], 
                         na.value = "grey80",
                         limits = c(0, 0.05), oob = scales::squish, 
                         labels = scales::percent)  +
    guides(fill = guide_colourbar(title = "STRs/\ndwelling",
                                  title.vjust = 1)) + 
    gg_bbox(active_EW) +
    theme_void() +
    theme(text = element_text(family = regular, face = "plain"),
          legend.title = element_text(family = regular, face = "bold",
                                      size = 7),
          legend.title.align = 0.9,
          legend.text = element_text(family = regular, size = 5),
          panel.border = element_rect(colour = "white", size = 2))
  
  right_map <- 
    active_DA %>% 
    ggplot() +
    geom_sf(data = province, colour = "transparent", fill = "grey93") +
    geom_sf(aes(fill = percentage), colour = "transparent") +
    geom_sf(data = water, fill = "white", colour = "transparent") +
    scale_fill_gradientn(colors = col_palette[c(5, 3, 4, 6)], 
                         na.value = "grey80",
                         limits = c(0, 0.05), oob = scales::squish, 
                         labels = scales::percent)  +
    guides(fill = guide_colourbar(title = "STRs/\ndwelling",
                                  title.vjust = 1)) + 
    gg_bbox(active_EW) +
    theme_void() +
    theme(text = element_text(family = regular, face = "plain"),
          legend.title = element_text(family = regular, face = "bold",
                                      size = 7),
          legend.title.align = 0.9,
          legend.text = element_text(family = regular, size = 5),
          panel.border = element_rect(colour = "white", size = 2))
  
  left_map + right_map + plot_layout(guide = "collect") & 
    theme(legend.position = "bottom", legend.key.width = unit(1.8, "lines"))

}

if (build_figures) {
  ggsave(here("output", "figures", "figure_1_2.pdf"), 
         plot = figure_1_2_fun("Futura", "Futura Condensed"), 
         width = 8, height = 4.2, units = "in", useDingbats = FALSE)
  
  extrafont::embed_fonts(here("output", "figures", "figure_1_2.pdf"))
}

```

STR activity in Prince Edward County is highly decentralized (Figure \@ref(fig:fig-1-2)), but seems to be less important in the Northern part of the county. Notably, when divided by electoral wards, Picton accounts for `r picton_listing_pct` of all listings and for `r picton_rev_pct` of all host revenue. Picton is followed by Hallowell (`r hallowell_listing_pct` of active listings and the biggest share of total revenue at  `r hallowell_rev_pct`) and Wellington (`r wellington_listing_pct` of active listings and `r wellington_rev_pct` of revenue). When measured in per-capita terms, Bloomfield has by far the highest concentrations of STRs per dwellings, at `r bloomfield_per_cap`, followed by Wellington with `r wellington_per_cap`. In all other wards, STRs account for between `r min_per_dwellings` and `r max_per_dwellings` of total dwellings.

``` {r fig-1-2, include = TRUE, fig.cap = '(ref:fig-1-2)', fig.align = "center"}

figure_1_2_fun()

```

(ref:fig-1-2) _Active STRs as a share of all dwelling units in Prince Edward County, by ward (L) and dissemination area (R)_

``` {r tab-1-1, include = TRUE}

library(kableExtra)

EW_breakdown %>% 
  arrange(-active_listings) %>% 
  mutate(active_listings = prettyNum(round(active_listings, -1), ","),
         active_growth_2019_2021 = scales::percent(active_growth_2019_2021, 0.1),
         listings_pct_dwellings = scales::percent(listings_pct_dwellings, 0.1),
         daily_rev = scales::dollar(round(daily_rev, -2)),
         rev_growth_2019_2021 = scales::percent(rev_growth_2019_2021, 0.1)) %>%
    select(ward, active_listings, active_growth_2019_2021, listings_pct_dwellings, daily_rev, rev_growth_2019_2021) %>% 
  add_row(ward = "Prince Edward County",
          active_listings = avg_listings_active,
          active_growth_2019_2021 = paste0("-", active_yoy_listings),
          listings_pct_dwellings = {
            avg_listings_active %>% 
              parse_number() %>% 
              {. / sum(EW$dwellings)} %>% 
              scales::percent(0.1)},
          daily_rev = daily_rev,
          rev_growth_2019_2021 = paste0("-", active_yoy_revenue),
          .before = 1) %>% 
  set_names(c("Ward", 
              "Active listings",
              "Annual listing growth (2019-2021)",
              "Active listings as % of dwellings",
              "Average Daily revenue",
              "Daily revenue growth (2019-2021)")) %>% 
  kbl(caption = "Wards with at least 20 daily active listings in 2021",
               align = "lrrrrr") %>% 
  kable_styling(latex_options="scale_down") %>% 
  row_spec(1, background = paste0(col_palette[2], "50"))

  
```

<br>

## Listing types and sizes

STRs listed on Airbnb can be one of four types: entire homes or apartments, private rooms, shared rooms, and hotel rooms. We have excluded the latter from our analysis, since we focus only on STRs located in housing units. Most policy attention has been focused on entire-home listings, both because these listings are most likely to generate harmful negative externalities, including housing loss and area nuisance, and because entire-home listings tend to be the most common. 

``` {r para_5, cache = TRUE, cache.lazy = FALSE, cache.extra = mtime(here("output", "str_processed.qsm"))}

qload(here("output", "str_processed.qsm"), nthreads = availableCores())

bedrooms <- 
  property %>% 
  st_drop_geometry() %>% 
  filter(property_ID %in% active_2021, listing_type == "Entire home/apt") %>% 
  mutate(bedrooms = if_else(bedrooms >= 3, "3+", as.character(bedrooms))) %>% 
  count(bedrooms) %>% 
  mutate(percentage = n / sum(n))

one_bedrooms <- 
  bedrooms %>% 
  filter(bedrooms == "1") %>% 
  pull(percentage) %>% 
  scales::percent(0.1)

two_bedrooms <- 
  bedrooms %>% 
  filter(bedrooms == "2") %>% 
  pull(percentage) %>% 
  scales::percent(0.1)

three_bedrooms <- 
  bedrooms %>% 
  filter(bedrooms == "3+") %>% 
  pull(percentage) %>% 
  scales::percent(0.1)

studios <- 
  bedrooms %>% 
  filter(bedrooms == "0") %>% 
  pull(percentage) %>% 
  scales::percent(0.1)

eh_3_bedroom <- 
  property %>% 
  filter(housing, scraped >= start_2021, 
         listing_type == "Entire home/apt", !is.na(bedrooms)) %>% 
  st_drop_geometry() %>% 
  summarize(bed_3 = mean(bedrooms <= 3)) %>% 
  pull(bed_3) %>% 
  scales::percent(0.1)

rm(property, daily, GH)

```

Table \@ref(tab:tab-1-2) provides the distribution of the listings by listing type in 2021. The vast majority of STRs in Prince Edward County are entire homes, a category which includes single-family homes, townhouses, apartments and condominiums. More than half (`r three_bedrooms`) of these were considerably large units with three-or-more-bedroom housing units, and a quarter (`r two_bedrooms`) were two-bedrooms units. A fifth (`r one_bedrooms`) had one bedroom, and only `r studios` were studios. In general, three-or-more-bedroom units are over-represented on STR platforms in comparison with the County’s overall housing stock.

``` {r tab-1-2, include = TRUE}

library(kableExtra)

# Exclude shared room as too marginal
listing_type_breakdown[1:2,] %>%
  mutate(active_listings = prettyNum(round(active_listings, digits = -1), ","),
         revenue = scales::dollar(revenue, 0.1, 1 / 1000000),
         pct_of_listings = scales::percent(pct_of_listings, 0.1),
         pct_of_revenue = scales::percent(pct_of_revenue, 0.1),
         pct_listing_growth_2019_2021 = scales::percent(pct_listing_growth_2019_2021, 0.1)) %>% 
  rename(`Listing type` = listing_type,
         `Active listings` = active_listings,
         `Annual revenue (million)` = revenue,
         `Share of all listings` = pct_of_listings,
         `Share of all revenue` = pct_of_revenue,
         `Listing growth (2019-2021)` = pct_listing_growth_2019_2021
         ) %>% 
  kbl(caption = "Listing type prevalence in Prince Edward County",
               align = "lrrrrr") %>% 
  kable_styling(latex_options="scale_down")

```

In 2021 entire-home listings accounted for `r eh_listings` of all daily active listings, and `r eh_revenue` of total host revenue. (Private rooms accounted for nearly all of the remainder.) Moreover, the dominance of entire-home listings in Prince Edward County’s STR market is increasing over time, as the private rooms' share of growth is lower than entire home's.

<br>

## STR growth rates

``` {r make_fig_1_3}

figure_1_3_fun <- function(regular = "", condensed = "") {
  
  daily_variation %>% 
  ggplot(aes(date, value, colour = var)) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "black") +
  geom_line(lwd = 1, na.rm = TRUE) +
  scale_x_date(name = NULL) +
  scale_y_continuous(name = NULL, limits = c(-1, NA), 
                     labels = scales::percent) +
  scale_color_manual(name = NULL, values = col_palette[c(5, 1)]) +
  theme_minimal() +
  theme(legend.position = "bottom", panel.grid.minor.x = element_blank(),
        text = element_text(family = regular))

}

if (build_figures) {
  ggsave(here("output", "figures", "figure_1_3.pdf"), 
         plot = figure_1_3_fun("Futura", "Futura Condensed"), 
         width = 8, height = 5, units = "in", useDingbats = FALSE)
  
  extrafont::embed_fonts(here("output", "figures", "figure_1_3.pdf"))
}

```

Until the end of 2019, there as been a decreasing growth in the number of active daily active STRs listing. Figure \@ref(fig:fig-1-3) shows the change in active listings and revenue relative to one year earlier, which is a convenient way to remove seasonal variation to identify underlying growth trends. The figure indicates that there was a yearly decreasing marginal growth until late 2019 and early 2020, by which time the number of STRs may have reached a plateau. The pandemic then caused a decline in the number of daily active STRs. Revenues, on the other hand, had seen degrowth in the winter season of 2018-2019, but apart from that have overall experienced constant growth. While revenues in summer 2020 had been mostly constant with a year prior, at around ~0% growth, We observe a strong growth during the summer of 2021, indicating an increase in tourist activity.

``` {r fig-1-3, include = TRUE, fig.cap = '(ref:fig-1-3)', fig.align = "center"}

figure_1_3_fun()

```

(ref:fig-1-3) _Change in daily active listings and host revenue compared to one year earlier (14-day average)_

``` {r para_6, cache = TRUE, cache.lazy = FALSE, cache.extra = mtime(here("output", "str_processed.qsm"))}

qload(here("output", "str_processed.qsm"), nthreads = availableCores())

#' YOY listing growth, 2019
listing_growth_2019 <- 
  daily %>% 
  filter(housing, status != "B", date >= start_2019 - years(1),
         date <= end_2019) %>% 
  group_by(year_2019 = date >= start_2019) %>% 
  summarize(n = n() / 365) %>% 
  summarize(change = (n[2] - n[1]) / n[1])  %>% 
  pull(change) %>% 
  scales::percent(0.1)

#' YOY listing growth, 2021
listing_growth_2021 <- 
  daily %>% 
  filter(housing, status != "B", date >= start_2019, 
         !c(date >= start_2020 & date <= end_2020)) %>% 
  group_by(year_2021 = date >= start_2021) %>% 
  summarize(n = n() / yday(max(date))) %>% 
  summarize(change = (n[2] - n[1]) / n[1])  %>% 
  pull(change) %>% 
  scales::percent(0.1)


rm(property, daily, GH)

```

Overall, the year-over-year change in average daily active listings from 2018 to 2019 was `r listing_growth_2019`, a small number that showcases that the market was saturated, that it had reached a plateau. Between 2019 and 2021, because of the Covid-19 pandemic, the change in active daily listings is `r listing_growth_2021`.

``` {r para_7, cache = TRUE, cache.lazy = FALSE, cache.extra = mtime(here("output", "str_processed.qsm"))}

qload(here("output", "str_processed.qsm"), nthreads = availableCores())

# YOY reservation change, 2019-2021
reservation_change_2021 <- 
  daily %>%
  filter(housing, status == "R", date >= start_2019, 
         !c(date >= start_2020 & date <= end_2020)) %>%
  group_by(year_2021 = date >= start_2021) %>%
  summarize(n = n() / yday(max(date))) %>%
  summarize(change = (n[2] - n[1]) / n[1]) %>% 
  pull(change) %>% 
  scales::percent(0.1)

# YOY reservation change, 2018-2019
reservation_change_2019 <- 
  daily %>%
  filter(housing, status == "R", date >= start_2019 - years(1),
         date <= end_2019) %>%
  group_by(year_2019 = date >= start_2019) %>%
  summarize(n = n()) %>%
  summarize(change = (n[2] - n[1]) / n[1]) %>% 
  pull(change) %>% 
  scales::percent(0.1)

# Reservation counts, 2019-2021
reservation_count_2021 <- 
  daily %>%
  filter(housing, status == "R", date >= start_2019, 
         !c(date >= start_2020 & date <= end_2020)) %>%
  group_by(year_2021 = date >= start_2021) %>%
  summarize(n = n() / yday(max(date))) %>% 
  mutate(n = round(n, -1)) %>% 
  pull(n)

# Reservation counts, 2018-2019
reservation_count_2019 <- 
  daily %>%
  filter(housing, status == "R", date >= start_2019 - years(1),
         date <= end_2019) %>%
  group_by(year_2019 = date >= start_2019) %>%
  summarize(n = n() /365) %>% 
  mutate(n = round(n, -1)) %>% 
  pull(n)

# YOY revenue change, 2019-2021
active_yoy_revenue_2021 <- 
  daily %>%
  filter(housing, status == "R", date >= start_2019, 
         !c(date >= start_2020 & date <= end_2020)) %>%
  group_by(year_2021 = date >= start_2021) %>%
  summarize(revenue = sum(price) / yday(max(date))) %>%
  summarize(change = (revenue[2] - revenue[1]) / revenue[1]) %>% 
  pull(change) %>% 
  {. * -1} %>% 
  scales::percent(0.1)


rm(property, daily, GH)

```

```{r active_listings, cache = TRUE, cache.lazy = FALSE, cache.extra = mtime(here("output", "str_processed.qsm"))}

qload(here("output", "str_processed.qsm"), nthreads = availableCores())

active_by_status <- 
  daily %>% 
  filter(status %in% c("R", "A")) %>% 
  count(date, status)

reserved_nights_increase_2019 <- 
  daily %>% 
  filter(housing, status == "R", date >= start_2019 - years(1), 
         date <= end_2019) %>% 
  count(year_2019 = date >= start_2019) %>% 
  summarize(growth = (n[2] - n[1]) / n[1]) %>% 
  pull(growth) %>% 
  scales::percent(0.1)

reserved_nights_decrease_2021 <- 
  daily %>% 
  filter(housing, status == "R", date >= start_2019, 
         !c(date >= start_2020 & date <= end_2020)) %>% 
  group_by(year_2021 = date >= start_2021) %>% 
  summarize(n = n() / yday(max(date))) %>% 
  summarize(growth = (n[2] - n[1]) / n[1]) %>% 
  pull(growth) %>% 
  scales::percent(0.1)

rm(property, daily, GH)

```

```{r reservation_trend, cache = TRUE, cache.lazy = FALSE, cache.extra = mtime(here("output", "str_processed.qsm"))}
# 
# library(feasts)
# library(fabletools)
# 
# qload(here("output", "str_processed.qsm"), nthreads = availableCores())
# 
# # Create and decompose reservations time series
# reservations <-
#   active_by_status %>%
#   filter(status == "R") %>%
#   tsibble::as_tsibble() %>%
#   tsibble::index_by(yearmon = tsibble::yearmonth(date)) %>%
#   summarize(n = sum(n)) %>%
#   filter(yearmon <= tsibble::yearmonth("2021-02")) %>%
#   model(x11 = feasts:::X11(n, type = "additive")) %>%
#   components()
# 
# # Get March-August seasonal
# mar_aug_seasonal <-
#   reservations %>%
#   slice(39:44) %>%
#   pull(seasonal)
# 
# # Get Feb trend
# feb_trend <-
#   reservations %>%
#   slice(50) %>%
#   pull(trend)
# 
# # Apply March-Aug seasonal component to Feb trend
# trends <-
#   tibble(
#     date = as.Date(c("2021-03-16", "2021-04-16", "2021-05-16", "2021-06-16",
#                      "2021-07-16", "2021-07-31")),
#     trend = (feb_trend + mar_aug_seasonal) / c(31, 30, 31, 30, 31, 31))
# 
# # Set July 31 value to average of July and August
# trends[6,]$trend <- mean(trends[5:6,]$trend)
# 
# reservations <-
#   active_by_status %>%
#   filter(status == "R") %>%
#   mutate(n = slide_dbl(n, mean, .before = 6)) %>%
#   filter(date >= "2019-01-01") %>%
#   left_join(trends) %>%
#   select(-status) %>%
#   mutate(trend = if_else(date == "2021-03-01", n, trend)) %>%
#   filter(date >= "2021-03-01") %>%
#   mutate(trend = zoo::na.approx(trend))
# 
# reservations <-
#   active_by_status %>%
#   filter(status == "R") %>%
#   mutate(n = slide_dbl(n, mean, .before = 6)) %>%
#   filter(date >= "2019-01-01", date <= "2021-02-29") %>%
#   select(-status) %>%
#   bind_rows(reservations)
# 
# # Reservation comparisons
# res_table <-
#   reservations %>%
#   filter(date == "2021-12-31") %>%
#   mutate(dif = trend - n, pct_change = 1 - n / trend)
# 
# res_2021 <-
#   prettyNum(round(res_table$n, -1), ",")
# 
# res_2021_trend <-
#   prettyNum(round(res_table$trend, -1), ",")
# 
# res_2021_pct <-
#   scales::percent(1 - res_table$n / res_table$trend, 0.1)
# 
# res_2021_dif <-
#   prettyNum(round(res_table$trend - res_table$n, -1), ",")
# 
# pandemic_reservations <-
#   reservations %>%
#   filter(date >= "2021-03-01") %>%
#   summarize(across(c(n, trend), sum)) %>%
#   mutate(dif = trend - n, pct = n / trend)
# 
# res_total_pandemic_dif <-
#   prettyNum(round(pandemic_reservations$trend - pandemic_reservations$n, -2),
#             ",")
# 
# res_total_pandemic <-
#   prettyNum(round(pandemic_reservations$n, -2), ",")
# 
# res_total_pandemic_pct <-
#   scales::percent(pandemic_reservations$n / pandemic_reservations$trend, 0.1)
# 
# res_total_pandemic_trend <-
#   prettyNum(round(pandemic_reservations$trend, -2), ",")

# rm(property, daily, GH)

```

``` {r make_fig_1_5}

 # figure_1_5_fun <- function(regular = "", condensed = "") {
 #   
 #  reservations %>% 
 #  pivot_longer(-date) %>% 
 #  filter(!is.na(value)) %>%
 #  ggplot() +
 #  annotate("rect", xmin = as.Date("2021-03-29"), xmax = as.Date("2021-06-25"),
 #           ymin = -Inf, ymax = Inf, alpha = 0.2) +
 #  geom_ribbon(aes(x = date, ymin = n, ymax = trend, group = 1),
 #              data = reservations, fill = col_palette[3], 
 #              alpha = 0.3) +
 #  geom_line(aes(date, value, color = name), lwd = 1) +
 #  geom_text(aes(x = as.Date("2021-07-31"), 
 #                y = mean(value[date == as.Date("2021-07-31")]),
 #                label = paste(
 #                  prettyNum(round(abs(diff(
 #                    value[date == as.Date("2021-07-31")])), -1), ","),
 #                  "fewer", "reservations", "than", "expected", sep = "\n")), 
 #            family = "Futura Condensed", inherit.aes = FALSE, hjust = 1,
 #            nudge_x = -4) +
 #  geom_segment(aes(x = as.Date("2021-07-31"), xend = as.Date("2021-07-31"),
 #                   y = min(value[date == as.Date("2021-07-31")]),
 #                   yend = max(value[date == as.Date("2021-07-31")])),
 #               colour = col_palette[3],
 #               arrow = arrow(length = unit(0.1, "cm"), ends = "both",
 #                             type = "open")) +
 #  scale_x_date(name = NULL) +
 #  scale_y_continuous(name = NULL, limits = c(0, NA), label = scales::comma) +
 #  scale_color_manual(name = NULL, 
 #                     labels = c("Actual reservations", "Expected reservations"), 
 #                     values = col_palette[c(5, 1)]) +
 #  theme_minimal() +
 #  theme(legend.position = "bottom", 
 #        panel.grid.minor.x = element_blank(),
 #        text = element_text(face = "plain", family = "Futura"), 
 #        legend.title = element_text(face = "bold", family = "Futura", 
 #                                    size = 10),
 #        legend.text = element_text( size = 10, family = "Futura"))
 # 
 # }
 # 
 # if (build_figures) {
 #   ggsave(here("output", "figures", "figure_1_5.pdf"), 
 #          plot = figure_1_5_fun("Futura", "Futura Condensed"), 
 #          width = 8, height = 5, units = "in", useDingbats = FALSE)
 #   
 #   extrafont::embed_fonts(here("output", "figures", "figure_1_5.pdf"))
 # }

```

<!-- Figure \@ref(fig:fig-1-5) provides a closer look at daily reservations since 2019, comparing the actual trajectory of reservations during the pandemic with what the trajectory of reservations would have been expected to be, based on previous growth in Prince Edward County's STR market but in the absence of the pandemic. (To do this, we use seasonal decomposition to identify the regular seasonal fluctuations in STR activity and separate them from the underlying patterns of growth or decline.) In total, from March through August 2021, we estimate that there have been r res_total_pandemic_dif fewer STR nights reserved than would normally have been expected to occur. The r res_total_pandemic total nights reserved in this time period is only r res_total_pandemic_pct of the r res_total_pandemic_trend nights total that would represent the previous growth trend. -->

``` {r fig-1-5, include = TRUE, fig.cap = '(ref:fig-1-5)', fig.align = "center"}

# figure_1_5_fun()

```

<!-- (ref:fig-1-5) _Actual and expected reservations during the Covid-19 pandemic (7-day average)_ -->

```{r prices, cache = TRUE, cache.lazy = FALSE, cache.extra = mtime(here("output", "str_processed.qsm"))}

qload(here("output", "str_processed.qsm"), nthreads = availableCores())
# 
# daily <- 
#   daily %>% 
#   # to not report on incomplete numbers, start at a date when VRBO is in our dataset
#   filter(date >= "2017-06-01")
# 
# # Get average nightly prices
# average_prices <-
#   daily %>%
#   filter(housing, status == "R",
#          listing_type == "Entire home/apt") %>%
#   group_by(date) %>%
#   summarize(price = mean(price))
# 
# # Create monthly price time series
# monthly_prices <-
#   average_prices %>%
#   tsibble::as_tsibble() %>%
#   tsibble::index_by(yearmon = tsibble::yearmonth(date)) %>%
#   summarize(price = mean(price))
# 
# # Get March-August seasonal
# mar_jul_price_seasonal <-
#   monthly_prices %>%
#   filter(yearmon <= tsibble::yearmonth("2021-02")) %>%
#   model(x11 = feasts:::X11(price, type = "additive")) %>%
#   components() %>%
#   slice(39:43) %>%
#   pull(seasonal)
# 
# # Get Feb trend
# feb_price_trend <-
#   monthly_prices %>%
#   filter(yearmon <= tsibble::yearmonth("2021-02")) %>%
#   model(x11 = feasts:::X11(price, type = "additive")) %>%
#   components() %>%
#   slice(50) %>%
#   pull(trend)
# 
# # Apply March-Aug seasonal component to Feb trend
# mar_jul_price_trend <-
#   tibble(yearmon = tsibble::yearmonth(c("2021-03", "2021-04", "2021-05",
#                                         "2021-06", "2021-07")),
#          trend = feb_price_trend + mar_jul_price_seasonal)
# 
# # Apply to daily averages to get trend
# average_prices <-
#   average_prices %>%
#   mutate(yearmon = tsibble::yearmonth(date)) %>%
#   inner_join(mar_jul_price_trend) %>%
#   group_by(yearmon) %>%
#   mutate(trend = price * trend / mean(price)) %>%
#   ungroup() %>%
#   select(date, trend) %>%
#   left_join(average_prices, .)
# 
#  nightly_price_dif <-
#    average_prices %>%
#    filter(date >= "2021-03-01") %>%
#    summarize(dif = 1 - sum(price) / sum(trend)) %>%
#    pull(dif) %>%
#    scales::percent(0.1)
# 
#  total_price_dif <-
#    average_prices %>%
#    rename(price_trend = trend) %>%
#    filter(date >= "2021-03-01") %>%
#    left_join(reservations) %>%
#    mutate(rev_dif = n * (price_trend - price)) %>%
#    tally(rev_dif) %>%
#    pull(n) %>%
#    scales::dollar(0.1, 1 / 1000000, suffix = " million")
# 
#  total_revenue_lost <-
#    average_prices %>%
#    rename(price_trend = trend) %>%
#    filter(date >= "2021-03-01") %>%
#    left_join(reservations) %>%
#    mutate(total_rev_dif = n * (price_trend - price) +
#             (trend - n) * price_trend) %>%
#    tally(total_rev_dif) %>%
#    pull(n) %>%
#    scales::dollar(0.1, 1 / 1000000, suffix = " million")

rm(property, daily, GH)

```

<!-- STR host daily revenue decreased by `r active_yoy_revenue` in 2021 compared to 2019. To offer some perspective, from 2018 to 2019, STR revenue increased by `r active_yoy_revenue_2019`. Throughout the May-December period of 2021, moreover, nightly prices have been an average of r nightly_price_diff lower than expected. Spread across the r res_total_pandemic nights reserved during this period, this means that STR operators collectively earned r total_price_dif less than they would have on their bookings in the absence of the pandemic. When the lower prices on reservations which did occur is combined with the reservations which did not occur, our estimate is that Prince Edward County’s STR hosts lost a total of r total_revenue_lost million in revenue between March and December 2021 because of the Covid-19 pandemic. -->

<br>

## Revenue distribution among STR hosts

A crucial concept for understanding the structure of a STR market is the distinction between casual STRs (“home sharing”) and dedicated STRs (“commercial operations”). One way to capture this distinction is to examine the distribution of revenue among STR hosts. Is revenue widely distributed between many part-time hosts of single listings, or concentrated among a small number of commercial operators who control many full-time listings?

While hosts are identified on Airbnb or Vrbo with unique accounts, these accounts are not necessarily an accurate guide to the individuals or companies which operate STR listings, since a given person or group of people can create as many host accounts as they wish, and split their listings among these accounts. What may appear superficially as a large number of small STR operators could thus be in reality a much smaller number of operators controlling many accounts each. To address this possibility, we use custom image recognition software to identify identical photographs which are used across multiple listings, and thereby construct groups of host accounts which are either a single operator or a network of operators working in collaboration. If multiple, apparently separate host accounts use the identical photo on the webpages of their STR listings, this is very strong evidence that these accounts are related.

``` {r para_9, cache = TRUE, cache.lazy = FALSE, cache.extra = mtime(here("output", "str_processed.qsm"))}

qload(here("output", "str_processed.qsm"), nthreads = availableCores())

# Host deciles table for figure
host_deciles <-
  daily %>%
  filter(housing, date >= start_2021, 
         status == "R", !is.na(host_ID)) %>%
  group_by(host_ID) %>%
  summarize(rev = sum(price)) %>% 
  summarize(all = sum(rev),
            top_10 = sum(rev[rev > quantile(rev, c(0.90))] / all),
            top_20 = sum(rev[rev > quantile(rev, c(0.80))] / all) - 
              sum(rev[rev > quantile(rev, c(0.90))] / all),
            top_30 = sum(rev[rev > quantile(rev, c(0.70))] / all) - 
              sum(rev[rev > quantile(rev, c(0.80))] / all),
            top_40 = sum(rev[rev > quantile(rev, c(0.60))] / all) - 
              sum(rev[rev > quantile(rev, c(0.70))] / all),
            top_50 = sum(rev[rev > quantile(rev, c(0.50))] / all) - 
              sum(rev[rev > quantile(rev, c(0.60))] / all),
            top_60 = sum(rev[rev > quantile(rev, c(0.40))] / all) - 
              sum(rev[rev > quantile(rev, c(0.50))] / all),
            top_70 = sum(rev[rev > quantile(rev, c(0.30))] / all) - 
              sum(rev[rev > quantile(rev, c(0.40))] / all),
            top_80 = sum(rev[rev > quantile(rev, c(0.20))] / all) - 
              sum(rev[rev > quantile(rev, c(0.30))] / all),
            top_90 = sum(rev[rev > quantile(rev, c(0.10))] / all) - 
              sum(rev[rev > quantile(rev, c(0.20))] / all),
            top_100 = sum(rev[rev > quantile(rev, c(0.00))] / all) - 
              sum(rev[rev > quantile(rev, c(0.10))] / all)) %>% 
  select(-all) %>% 
  pivot_longer(everything(), names_to = "percentile", values_to = "value") %>% 
  mutate(percentile = factor(percentile, levels = paste0("top_", 1:10 * 10))) %>% 
  mutate(perfect_distribution = 0.1,
         decile = 1:10,
         dummy_1 = perfect_distribution,
         dummy_2 = value) %>%  
  rename("0" = perfect_distribution, "1" = value, "0.25" = dummy_1, 
         "0.75" = dummy_2) %>%
  pivot_longer(c("0","0.25", "0.75", "1"), names_to = "position") %>% 
  mutate(position = as.numeric(position),
         display_val = scales::percent(value, .1)) %>% 
  group_by(position) %>% 
  mutate(absolute_val = slide_dbl(value, ~{.x[1] / 2 + sum(.x[-1])}, 
                                  .after = 9)) %>% 
  ungroup() %>% 
  mutate(
    display_val = paste0("earned ", display_val, "\nof revenue"),
    display_percentile = case_when(
      percentile == "top_10" ~ "Top 10% of hosts...",
      percentile == "top_20" ~ "Next 10% of hosts...",
      TRUE ~ NA_character_))

top_host_listings <- 
  property %>% 
  filter(host_ID == host_rev[which.max(host_rev$rev),]$host_ID) %>% 
  nrow()

top_host_rev <- 
  host_rev %>% 
  filter(rev == max(rev)) %>% 
  pull(rev) %>% 
  scales::dollar(accuracy = 0.1, scale = 1 / 1000000, suffix = " million")

median_host_rev <- 
  median(host_rev$rev) %>%
  scales::dollar(accuracy = 100)

n_hosts_over_100 <- 
  host_rev %>% 
  filter(rev >= 100000) %>% 
  nrow()

host_rev_top_10 <- 
  host_rev %>% 
  summarize(top_10 = sum(rev[rev > quantile(rev, .9)]) / sum(rev)) %>% 
  pull(top_10) %>% 
  scales::percent(0.1)

host_rev_top_5 <- 
  host_rev %>% 
  summarize(top_5 = sum(rev[rev > quantile(rev, .95)]) / sum(rev)) %>% 
  pull(top_5) %>% 
  scales::percent(0.1)

host_rev_top_1 <- 
  host_rev %>% 
  summarize(top_1 = sum(rev[rev > quantile(rev, .99)]) / sum(rev)) %>% 
  pull(top_1) %>% 
  scales::percent(0.1)

#### same for 2019

host_deciles_2019 <-
  daily %>%
  filter(housing, date >= start_2019, date <= str_replace(max(daily$date), "^\\d{4}", "2019"), 
         status == "R", !is.na(host_ID)) %>%
  group_by(host_ID) %>%
  summarize(rev = sum(price)) %>% 
  summarize(all = sum(rev),
            top_10 = sum(rev[rev > quantile(rev, c(0.90))] / all),
            top_20 = sum(rev[rev > quantile(rev, c(0.80))] / all) - 
              sum(rev[rev > quantile(rev, c(0.90))] / all),
            top_30 = sum(rev[rev > quantile(rev, c(0.70))] / all) - 
              sum(rev[rev > quantile(rev, c(0.80))] / all),
            top_40 = sum(rev[rev > quantile(rev, c(0.60))] / all) - 
              sum(rev[rev > quantile(rev, c(0.70))] / all),
            top_50 = sum(rev[rev > quantile(rev, c(0.50))] / all) - 
              sum(rev[rev > quantile(rev, c(0.60))] / all),
            top_60 = sum(rev[rev > quantile(rev, c(0.40))] / all) - 
              sum(rev[rev > quantile(rev, c(0.50))] / all),
            top_70 = sum(rev[rev > quantile(rev, c(0.30))] / all) - 
              sum(rev[rev > quantile(rev, c(0.40))] / all),
            top_80 = sum(rev[rev > quantile(rev, c(0.20))] / all) - 
              sum(rev[rev > quantile(rev, c(0.30))] / all),
            top_90 = sum(rev[rev > quantile(rev, c(0.10))] / all) - 
              sum(rev[rev > quantile(rev, c(0.20))] / all),
            top_100 = sum(rev[rev > quantile(rev, c(0.00))] / all) - 
              sum(rev[rev > quantile(rev, c(0.10))] / all)) %>% 
  select(-all) %>% 
  pivot_longer(everything(), names_to = "percentile", values_to = "value") %>% 
  mutate(percentile = factor(percentile, levels = paste0("top_", 1:10 * 10))) %>% 
  mutate(perfect_distribution = 0.1,
         decile = 1:10,
         dummy_1 = perfect_distribution,
         dummy_2 = value) %>%  
  rename("0" = perfect_distribution, "1" = value, "0.25" = dummy_1, 
         "0.75" = dummy_2) %>%
  pivot_longer(c("0","0.25", "0.75", "1"), names_to = "position") %>% 
  mutate(position = as.numeric(position),
         display_val = scales::percent(value, .1)) %>% 
  group_by(position) %>% 
  mutate(absolute_val = slide_dbl(value, ~{.x[1] / 2 + sum(.x[-1])}, 
                                  .after = 9)) %>% 
  ungroup() %>% 
  mutate(
    display_val = paste0("earned ", display_val, "\nof revenue"),
    display_percentile = case_when(
      percentile == "top_10" ~ "Top 10% of hosts...",
      percentile == "top_20" ~ "Next 10% of hosts...",
      TRUE ~ NA_character_))

top_host_listing_2019 <- 
  property %>% 
  filter(host_ID == host_rev[which.max(host_rev_2019$rev),]$host_ID) %>% 
  nrow()

top_host_rev_2019 <- 
  host_rev_2019 %>% 
  filter(rev == max(rev)) %>% 
  pull(rev) %>% 
  scales::dollar(accuracy = 0.1, scale = 1 / 1000000, suffix = " million")

median_host_rev_2019 <- 
  median(host_rev_2019$rev) %>%
  scales::dollar(accuracy = 100)

n_hosts_over_100_2019 <- 
  host_rev_2019 %>% 
  filter(rev >= 100000) %>% 
  nrow()

host_rev_top_10_2019 <- 
  host_rev_2019 %>% 
  summarize(top_10 = sum(rev[rev > quantile(rev, .9)]) / sum(rev)) %>% 
  pull(top_10) %>% 
  scales::percent(0.1)

host_rev_top_5_2019 <- 
  host_rev_2019 %>% 
  summarize(top_5 = sum(rev[rev > quantile(rev, .95)]) / sum(rev)) %>% 
  pull(top_5) %>% 
  scales::percent(0.1)

host_rev_top_1_2019 <- 
  host_rev_2019 %>% 
  summarize(top_1 = sum(rev[rev > quantile(rev, .99)]) / sum(rev)) %>% 
  pull(top_1) %>% 
  scales::percent(0.1)

diff_host_100 <- 
  n_hosts_over_100_2019 - n_hosts_over_100

# End month
end_month <- 
  max(daily$date) %>% 
  substr(6, 7) %>% 
  as.numeric() %>% 
  {month.name[.]}

rm(property, daily, GH)

```

``` {r make_fig_1_6}

figure_1_6_fun <- function(regular = "", condensed = "") {
  
  revenue_colour <- colorRampPalette(col_palette[c(7, 6, 1, 4, 3, 2, 5)])(10)

  host_deciles %>% 
  ggplot(aes(position, value, group = decile, fill = decile)) +
  geom_area(colour = "white", lwd = 1.2) +
  geom_text(aes(x = 0.02, y = absolute_val, label = display_percentile), 
            data = filter(host_deciles, position == 0, decile <= 2),
            family = regular, 
            hjust = 0) +
  geom_text(aes(x = 0.98, y = absolute_val, label = display_val), 
            data = filter(host_deciles, position == 1, decile <= 2),
            family = regular, 
            hjust = 1) +
  scale_y_continuous(name = "Host decile", label = scales::label_percent(1),
                     breaks = seq(0, 1, by = 0.1), limits = c(0, 1),
                     sec.axis = sec_axis(~., 
                                         name = "% of total revenue",
                                         labels = derive(), 
                                         breaks = derive())) +
  scale_fill_gradientn(colours = revenue_colour) +
  theme_void() +
  theme(legend.position = "none",
        text = element_text(family = regular),
        axis.text.y = element_text(hjust = 1),
        axis.title.y.left = element_text(
          angle = 90, margin = margin(0, 10, 0, 0)),
        axis.title.y.right = element_text(
          angle = 270, margin = margin(0, 0, 0, 10)),
        axis.title.x = element_blank(), 
        axis.text.x = element_blank())

}

if (build_figures) {
  ggsave(here("output", "figures", "figure_1_6.pdf"), 
         plot = figure_1_6_fun("Futura", "Futura Condensed"), 
         width = 8, height = 5, units = "in", useDingbats = FALSE)
  
  extrafont::embed_fonts(here("output", "figures", "figure_1_6.pdf"))
}

```

Among all the STR hosts who earned revenue in Prince Edward County in 2021, the median revenue from January to `r end_month` was `r median_host_rev`. Throughout the county, there were `r n_hosts_over_100` hosts that earned more than $100,000 in 2021, which is `r diff_host_100` less hosts than during the same months of 2019. Figure \@ref(fig:fig-1-6) shows the percentage of the total `r daily_rev` in STR daily revenue which accrued to each decile of hosts. The figure shows that revenue is disproportionately concentrated among a small number of hosts; the top 10% earned `r host_rev_top_10`: the top 5% earned `r host_rev_top_5` of revenue, while the top 1% of hosts earned `r host_rev_top_1` of all revenue. The pandemic hasn't impacted the revenue distribution among STR hosts. To put this revenue distribution in context, Montreal’s top 10% of STR hosts earned 68.8% of all revenue in 2019. On the other hand, Vancouver's top 10% hosts only earned 43.2% of all revenue in 2019. **TKTK Are big cities the good comparison here? Probably to show how different PEC is from other STR destination! But what's of interested for the county? Such a comparison, or one that shows it's similar to other seasonal destination? Maybe both?**

``` {r fig-1-6, include = TRUE, fig.cap = '(ref:fig-1-6)', fig.align = "center"}

figure_1_6_fun()

```

(ref:fig-1-6) _STR host revenue distribution in Prince Edward County_

<br>

## The commercialization of Prince Edward County’s STR market

Some hosts operate multiple STR units, which strongly suggests that they are commercial operators rather than a casual home sharers. To take the simplest case, a host with two or more entire-home listings on the same day cannot be operating both listings out of their principal residence. We consider entire-homes to be "multilistings" if they are operated by hosts who are simultaneously operating other entire-home listings. We define private-room multilistings as cases where a host has three or more private-room listings operating on the same day. Since `r eh_3_bedroom` of entire-home listings have three or fewer bedrooms, there will be limited cases where a host operating three private-room STR listings in a dwelling unit has not converted the entire unit into a dedicated STR. 

``` {r para_10, cache = TRUE, cache.lazy = FALSE, cache.extra = mtime(here("output", "str_processed.qsm"))}

qload(here("output", "str_processed.qsm"), nthreads = availableCores())

# ML table for figure
ML <- 
  daily %>% 
  filter(status != "B") %>% 
  group_by(date) %>% 
  summarize(Listings = mean(multi),
            Revenue = sum(price[status == "R" & multi], na.rm = TRUE) / 
              sum(price[status == "R"], na.rm = TRUE)) %>% 
  mutate(across(where(is.numeric), slide_dbl, mean, .before = 13)) %>% 
  pivot_longer(c(Listings, Revenue), names_to = "Multilisting percentage",
               values_to = "value")

ML_per_listings_rev <- 
ML %>% 
  filter(date >= "2018-01-01") %>% 
  group_by(`Multilisting percentage`) %>% 
  summarize(n = mean(value)) %>% 
  pull(n) %>% 
  scales::percent(., accuracy = 0.1)

rm(property, daily, GH)

```

``` {r make_fig_1_7}

figure_1_7_fun <- function(regular = "", condensed = "") {
  
  ML %>% 
    filter(date >= "2017-06-01") %>% 
    ggplot() +
    geom_line(aes(date, value, colour = `Multilisting percentage`), lwd = 1) +
    scale_x_date(name = NULL) +
    scale_y_continuous(name = NULL, 
                       label = scales::percent_format(accuracy = 1)) +
    scale_colour_manual(values = col_palette[c(5, 1)]) +
    theme_minimal() +
    theme(legend.position = "bottom",
          panel.grid.minor.x = element_blank(),
          text = element_text(family = regular, face = "plain"),
          legend.title = element_text(family = regular, face = "bold"),
          legend.text = element_text(family = regular))

}

if (build_figures) {
  ggsave(here("output", "figures", "figure_1_7.pdf"), 
         plot = figure_1_7_fun("Futura", "Futura Condensed"), 
         width = 8, height = 5, units = "in", useDingbats = FALSE)
  
  extrafont::embed_fonts(here("output", "figures", "figure_1_7.pdf"))
}

```

In 2021, `r ml_listings` of active listings in Prince Edward County were multilistings, earning `r ml_revenue` of total host revenue. Multilistings had been steady since 2018, at ~50% on average, both in terms of listings (`r ML_per_listings_rev[1]`) and revenue percentage (`r ML_per_listings_rev[2]`). If the Covid-19 pandemic impacted their proportion, it was marginal and only on the revenue side (Figure \@ref(fig:fig-1-7)). Multilistings were and are earning close to 1 out of every 2 dollars on STR platforms in Prince Edward County. 

``` {r fig-1-7, include = TRUE, fig.cap = '(ref:fig-1-7)', fig.align = "center"}

figure_1_7_fun()

```

(ref:fig-1-7) _The percentage of active listings and revenue accounted for by multilistings in Prince Edward County (14-day average)_

These figures should be taken as highly conservative estimates. Many commercial operators will use different Airbnb or Vrbo accounts to manage their listings. If multiple listings share the same photographs then our image recognition software will be able to connect them together, but it is otherwise difficult to determine whether two accounts belong to the same person. Moreover, many STR commercial operators only operate a single listing, but operate it on a full-time basis. A house owner with a secondary suite, or the owner of an investment apartment who operates a STR in it, are clearly commercial operators running listings which are not their principal residences, but they would not be counted by this method.

<br>

## Prince Edward County in comparison with other major tourist cities

TKTK

\newpage
